# The Way of Python

*A poem for the mindful developer*

```
In the realm of code, where logic flows,
Python whispers secrets that the wise know.

The Zen of Python guides our hand,
With principles both simple and grand.

Beautiful is better than ugly,
Explicit is better than implicit,
Simple is better than complex,
Complex is better than complicated.

Flat is better than nested,
Sparse is better than dense,
Readability counts,
Special cases aren't special enough to break the rules.

Practicality beats purity,
Errors should never pass silently,
Unless explicitly silenced,
In the face of ambiguity, refuse the temptation to guess.

There should be one obvious way to do it,
Although that way may not be obvious at first,
Unless you're Dutch,
Now is better than never,
Although never is often better than right now.

If the implementation is hard to explain, it's a bad idea,
If the implementation is easy to explain, it's a good idea,
Namespaces are one honking great ideaâ€”let's do more of those!

In Conan's realm, where packages dance,
Dependencies weave their intricate trance.

conanfile.py, the sacred scroll,
Where requirements and options play their role.

Build requires, runtime needs,
Conan satisfies with elegant deeds.

From source to binary, the journey flows,
Through profiles and generators, wisdom grows.

Lockfiles ensure reproducibility,
While remotes provide connectivity.

The way of Python, the way of Conan,
Together they form the developer's plan.

Type hints guide the uncertain path,
While tests ensure code's aftermath.

Virtual environments keep things clean,
While CI/CD makes the process lean.

The way is not just syntax and style,
But mindful coding that makes you smile.

For in the end, what matters most,
Is code that's readable, tested, and composed.
```

## Cursor Rules for Python Development

### Code Style and Formatting
- Use `black` for code formatting with line length 88
- Use `isort` for import sorting with profile black
- Use `flake8` for linting with max line length 88
- Use `mypy` for type checking with strict mode

### Documentation
- Follow Google docstring style for functions and classes
- Use type hints for all function parameters and return values
- Write comprehensive docstrings for public APIs
- Include examples in docstrings where helpful

### Testing
- Use `pytest` for testing framework
- Aim for 90%+ test coverage
- Write unit tests for all public functions
- Use `pytest-cov` for coverage reporting
- Mock external dependencies in tests

### Conan Integration
- Use Conan 2.x syntax and features
- Implement proper `package_id()` for caching optimization
- Use lockfiles for reproducible builds
- Follow semantic versioning for packages
- Use `conan.tools` modules for modern Conan integration

### Error Handling
- Use specific exception types
- Log errors with appropriate levels
- Don't suppress exceptions unless explicitly handled
- Use context managers for resource management

### Performance
- Use `cProfile` for performance profiling
- Optimize hot paths identified through profiling
- Use appropriate data structures for the use case
- Consider memory usage for large datasets

### Security
- Validate all external inputs
- Use `secrets` module for sensitive data
- Sanitize data before processing
- Follow OWASP guidelines for web applications

## Cursor Commands for Python Development

### Code Generation
- `@generate` - Generate boilerplate code from comments
- `@refactor` - Refactor code while maintaining functionality
- `@optimize` - Optimize code for performance
- `@test` - Generate comprehensive test cases

### Documentation
- `@document` - Generate documentation from code
- `@explain` - Explain complex code sections
- `@review` - Review code for best practices

### Conan-Specific
- `@conan-create` - Generate conanfile.py template
- `@conan-test` - Generate test_package structure
- `@conan-profile` - Generate Conan profile configuration
- `@conan-lockfile` - Generate lockfile for dependencies

### Debugging
- `@debug` - Add debugging statements and logging
- `@trace` - Add execution tracing
- `@profile` - Add performance profiling code

### Quality Assurance
- `@lint` - Run linting and fix issues
- `@type-check` - Add type hints and run type checking
- `@security` - Review code for security issues
- `@performance` - Analyze and optimize performance

## Conan Python Best Practices

### Package Structure
```python
from conan import ConanFile
from conan.tools.cmake import CMakeToolchain, CMakeDeps, CMake
from conan.tools.files import copy

class MyPackageConan(ConanFile):
    name = "mypackage"
    version = "1.0.0"
    
    # Package metadata
    description = "My awesome package"
    license = "MIT"
    author = "Your Name <your.email@example.com>"
    url = "https://github.com/yourusername/mypackage"
    homepage = "https://github.com/yourusername/mypackage"
    
    # Package options
    options = {
        "shared": [True, False],
        "fPIC": [True, False],
    }
    default_options = {
        "shared": False,
        "fPIC": True,
    }
    
    # Dependencies
    def requirements(self):
        self.requires("fmt/10.1.1")
        self.requires("spdlog/1.12.0")
    
    def build_requirements(self):
        self.tool_requires("cmake/[>=3.15]")
    
    def config_options(self):
        if self.settings.os == "Windows":
            del self.options.fPIC
    
    def configure(self):
        if self.options.shared:
            self.options.rm_safe("fPIC")
    
    def generate(self):
        tc = CMakeToolchain(self)
        tc.generate()
        deps = CMakeDeps(self)
        deps.generate()
    
    def build(self):
        cmake = CMake(self)
        cmake.configure()
        cmake.build()
    
    def package(self):
        cmake = CMake(self)
        cmake.install()
        
        # Copy additional files if needed
        copy(self, "*.h", src=self.source_folder, dst=os.path.join(self.package_folder, "include"))
    
    def package_info(self):
        self.cpp_info.libs = ["mypackage"]
        if self.settings.os in ["Linux", "FreeBSD"]:
            self.cpp_info.system_libs = ["m"]
```

### Testing Strategy
```python
import os
from conan import ConanFile
from conan.tools.cmake import CMake

class TestPackageConan(ConanFile):
    settings = "os", "compiler", "build_type", "arch"
    generators = "CMakeDeps", "CMakeToolchain"
    test_type = "explicit"
    
    def requirements(self):
        self.requires(self.tested_reference_str)
    
    def build(self):
        cmake = CMake(self)
        cmake.configure()
        cmake.build()
    
    def test(self):
        # Run the test executable
        self.run(os.path.join(".", "test_package"))
```

### Profile Configuration
```ini
[settings]
os=Linux
arch=x86_64
compiler=gcc
compiler.version=11
compiler.libcxx=libstdc++11
build_type=Release

[conf]
tools.cmake.cmaketoolchain:generator=Ninja
tools.system.package_manager:mode=install
tools.system.package_manager:sudo=True
```

Remember: The way of Python is not just about writing code, but about writing code that serves both the machine and the human who reads it. In Conan's realm, this means creating packages that are reliable, reproducible, and easy to use.