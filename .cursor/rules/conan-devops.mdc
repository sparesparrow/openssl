---
description: Conan DevOps best practices for OpenSSL (packaging, profiles, caching)
globs: ["conanfile.py", "conan/**", "conan-profiles/**/*.profile", "**/profiles/*.profile", "scripts/**/*.py", ".github/workflows/**/*.yml"]
alwaysApply: true
---

# Conan DevOps Best Practices Rules

Based on analysis of oms-dev project and Michal's DevOps engineering practices.

## Conan Package Management Rules

### Package Structure and Organization
- **Always use semantic versioning** with proper version pinning in conanfile.py
- **Implement proper package_id()** to optimize caching and avoid unnecessary rebuilds
- **Use lockfiles for reproducible builds** - generate lockfiles for each environment
- **Structure dependencies hierarchically** with clear separation between build_requires and requires

### Dependency Management
- **Pin exact versions** for critical dependencies to avoid version drift
- **Use version ranges carefully** - prefer exact pins for production builds
- **Implement dependency conflict resolution** in configure() method
- **Generate SBOM (Software Bill of Materials)** for supply chain security

### Build Configuration
- **Use hermetic profiles** with pinned toolchain versions for reproducibility
- **Implement ABI-strict configurations** to prevent compatibility issues
- **Configure compiler caching** (ccache/sccache) for faster builds
- **Set up proper build parallelization** with jobs parameter

### CI/CD Integration
- **Implement multi-tier remote strategy** (dev, staging, prod)
- **Use binary-first approach** - prefer prebuilt packages over source builds
- **Implement package promotion workflow** with proper testing gates
- **Set up artifact lifecycle management** with retention policies

## Michal's Automation Patterns

### Automated Package Updates
- **Implement automated conanfile.py updates** for dependency version bumps
- **Use CI/CD triggers** for automatic package updates when dependencies change
- **Maintain automated testing** for updated packages
- **Implement rollback mechanisms** for failed automated updates

### Build Optimization
- **Use intelligent caching strategies** to reduce build times
- **Implement incremental builds** with proper cache keys
- **Set up cross-platform binary reuse** where ABI-compatible
- **Optimize package ID strategies** for better cache hit rates

### Quality Assurance
- **Implement comprehensive testing** for all package configurations
- **Use hermetic test environments** to avoid flaky tests
- **Set up security scanning** for dependencies and packages
- **Implement build provenance tracking** for compliance

## OpenSSL-Specific Considerations

### Security-First Approach
- **Enable FIPS mode** for production builds when required
- **Implement proper cryptographic algorithm selection** based on security requirements
- **Set up vulnerability scanning** for OpenSSL and its dependencies
- **Maintain security update procedures** for critical vulnerabilities

### Performance Optimization
- **Use assembly optimizations** for performance-critical builds
- **Implement proper threading support** configuration
- **Configure memory debugging** for development builds
- **Set up sanitizer support** for comprehensive testing

### Cross-Platform Compatibility
- **Support multiple architectures** (x86_64, ARM64, etc.)
- **Handle platform-specific configurations** properly
- **Implement proper Windows/macOS/Linux support**
- **Use consistent toolchain versions** across platforms

## Implementation Guidelines

### Conanfile.py Structure
```python
class OpenSSLConan(ConanFile):
    # Use proper metadata
    name = "openssl"
    version = "3.5.0"  # Dynamic from VERSION.dat
    
    # Comprehensive options for flexibility
    options = {
        "shared": [True, False],
        "fips": [True, False],
        # ... other options
    }
    
    def package_id(self):
        # Optimize for caching
        del self.info.options.build_tests
        # Group compatible configurations
        
    def _generate_sbom(self):
        # Generate SBOM for supply chain security
        pass
```

### Profile Configuration
```ini
# Use hermetic profiles with pinned versions
[settings]
os=Linux
compiler=gcc
compiler.version=11
compiler.libcxx=libstdc++11

[conf]
# Enable caching and optimization
tools.env:CCACHE_DIR=/cache/ccache
tools.cmake.cmaketoolchain:jobs=8
```

### CI/CD Pipeline Structure
- **Phase 1**: Build packages with lockfiles
- **Phase 2**: Run comprehensive tests
- **Phase 3**: Security scanning and validation
- **Phase 4**: Package promotion and deployment

## Monitoring and Observability

### Build Metrics
- **Track build times** and cache hit rates
- **Monitor dependency resolution** performance
- **Measure package promotion** success rates
- **Analyze rebuild triggers** and optimization opportunities

### Quality Metrics
- **Track test coverage** across configurations
- **Monitor security scan** results
- **Measure package stability** metrics
- **Analyze dependency vulnerabilities**

## Best Practices Summary

1. **Reproducibility**: Use hermetic builds with pinned toolchains
2. **Performance**: Implement intelligent caching and binary reuse
3. **Security**: Generate SBOMs and scan for vulnerabilities
4. **Automation**: Automate package updates and testing
5. **Quality**: Comprehensive testing and validation
6. **Observability**: Monitor and analyze build performance
7. **Compliance**: Maintain audit trails and provenance
8. **Scalability**: Design for growth and platform expansion

These rules ensure modern, efficient, and secure DevOps practices for OpenSSL development using Conan and Python automation.